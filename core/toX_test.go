package core

import (
	"fmt"
	"os"
	"testing"
	"time"
)

func TestToX(t *testing.T) {
	os.Setenv("ANKO_DEBUG", "1")
	tests := []testStruct{
		{script: `toBool(-2)`, runOutput: false},
		{script: `toBool(-1.5)`, runOutput: false},
		{script: `toBool(-1)`, runOutput: false},
		{script: `toBool(-0.4)`, runOutput: false},
		{script: `toBool(0)`, runOutput: false},
		{script: `toBool(0.4)`, runOutput: true},
		{script: `toBool(1)`, runOutput: true},
		{script: `toBool(1.5)`, runOutput: true},
		{script: `toBool(2)`, runOutput: true},
		{script: `toBool("true")`, runOutput: true},
		{script: `toBool("false")`, runOutput: false},
		{script: `toBool("yes")`, runOutput: true},
		{script: `toBool("ye")`, runOutput: false},
		{script: `toBool("y")`, runOutput: true},
		{script: `toBool("false")`, runOutput: false},
		{script: `toBool("f")`, runOutput: false},
		{script: `toBool("")`, runOutput: false},
		{script: `toBool(nil)`, runOutput: false},
		{script: `toBool({})`, runOutput: false},
		{script: `toBool([])`, runOutput: false},
		{script: `toBool([true])`, runOutput: false},
		{script: `toBool({"true": "true"})`, runOutput: false},
		{script: `toString(nil)`, runOutput: "<nil>"},
		{script: `toString("")`, runOutput: ""},
		{script: `toString(1)`, runOutput: "1"},
		{script: `toString(1.2)`, runOutput: "1.2"},
		{script: `toString(1/3)`, runOutput: "0.3333333333333333"},
		{script: `toString(false)`, runOutput: "false"},
		{script: `toString(true)`, runOutput: "true"},
		{script: `toString({})`, runOutput: "map[]"},
		{script: `toString({"foo": "bar"})`, runOutput: "map[foo:bar]"},
		{script: `toString([true,nil])`, runOutput: "[true <nil>]"},
		{script: `toInt(nil)`, runOutput: int64(0)},
		{script: `toInt(-2)`, runOutput: int64(-2)},
		{script: `toInt(-1.4)`, runOutput: int64(-1)},
		{script: `toInt(-1)`, runOutput: int64(-1)},
		{script: `toInt(0)`, runOutput: int64(0)},
		{script: `toInt(1)`, runOutput: int64(1)},
		{script: `toInt(1.4)`, runOutput: int64(1)},
		{script: `toInt(1.5)`, runOutput: int64(1)},
		{script: `toInt(1.9)`, runOutput: int64(1)},
		{script: `toInt(2)`, runOutput: int64(2)},
		{script: `toInt(2.1)`, runOutput: int64(2)},
		{script: `toInt(true)`, runOutput: int64(1)},
		{script: `toInt(false)`, runOutput: int64(0)},
		{script: `toInt({})`, runOutput: int64(0)},
		{script: `toInt([])`, runOutput: int64(0)},
		{script: `toFloat(nil)`, runOutput: float64(0.0)},
		{script: `toFloat(-2)`, runOutput: float64(-2.0)},
		{script: `toFloat(-1.4)`, runOutput: float64(-1.4)},
		{script: `toFloat(-1)`, runOutput: float64(-1.0)},
		{script: `toFloat(0)`, runOutput: float64(0.0)},
		{script: `toFloat(1)`, runOutput: float64(1.0)},
		{script: `toFloat(1.4)`, runOutput: float64(1.4)},
		{script: `toFloat(1.5)`, runOutput: float64(1.5)},
		{script: `toFloat(1.9)`, runOutput: float64(1.9)},
		{script: `toFloat(2)`, runOutput: float64(2.0)},
		{script: `toFloat(2.1)`, runOutput: float64(2.1)},
		{script: `toFloat(true)`, runOutput: float64(1.0)},
		{script: `toFloat(false)`, runOutput: float64(0.0)},
		{script: `toFloat({})`, runOutput: float64(0.0)},
		{script: `toFloat([])`, runOutput: float64(0.0)},
		{script: `toBoolSlice(nil)`, runOutput: []bool{}},
		{script: `toBoolSlice(1)`, runError: fmt.Errorf("function wants argument type []interface {} but received type int64")},
		{script: `toBoolSlice(1.2)`, runError: fmt.Errorf("function wants argument type []interface {} but received type float64")},
		{script: `toBoolSlice(false)`, runError: fmt.Errorf("function wants argument type []interface {} but received type bool")},
		{script: `toBoolSlice({})`, runError: fmt.Errorf("function wants argument type []interface {} but received type map[string]interface {}")},
		{script: `toBoolSlice([])`, runOutput: []bool{}},
		{script: `toBoolSlice([nil])`, runOutput: []bool{false}},
		{script: `toBoolSlice([1])`, runOutput: []bool{false}},
		{script: `toBoolSlice([1.1])`, runOutput: []bool{false}},
		{script: `toBoolSlice([true])`, runOutput: []bool{true}},
		{script: `toBoolSlice([[]])`, runOutput: []bool{false}},
		{script: `toBoolSlice([{}])`, runOutput: []bool{false}},
		{script: `toIntSlice(nil)`, runOutput: []int64{}},
		{script: `toIntSlice(1)`, runError: fmt.Errorf("function wants argument type []interface {} but received type int64")},
		{script: `toIntSlice(1.2)`, runError: fmt.Errorf("function wants argument type []interface {} but received type float64")},
		{script: `toIntSlice(false)`, runError: fmt.Errorf("function wants argument type []interface {} but received type bool")},
		{script: `toIntSlice({})`, runError: fmt.Errorf("function wants argument type []interface {} but received type map[string]interface {}")},
		{script: `toIntSlice([])`, runOutput: []int64{}},
		{script: `toIntSlice([nil])`, runOutput: []int64{0}},
		{script: `toIntSlice([1])`, runOutput: []int64{1}},
		{script: `toIntSlice([1.1])`, runOutput: []int64{1}},
		{script: `toIntSlice([true])`, runOutput: []int64{0}},
		{script: `toIntSlice([[]])`, runOutput: []int64{0}},
		{script: `toIntSlice([{}])`, runOutput: []int64{0}},
		{script: `toFloatSlice(nil)`, runOutput: []float64{}},
		{script: `toFloatSlice(1)`, runError: fmt.Errorf("function wants argument type []interface {} but received type int64")},
		{script: `toFloatSlice(1.2)`, runError: fmt.Errorf("function wants argument type []interface {} but received type float64")},
		{script: `toFloatSlice(false)`, runError: fmt.Errorf("function wants argument type []interface {} but received type bool")},
		{script: `toFloatSlice({})`, runError: fmt.Errorf("function wants argument type []interface {} but received type map[string]interface {}")},
		{script: `toFloatSlice([])`, runOutput: []float64{}},
		{script: `toFloatSlice([nil])`, runOutput: []float64{0.0}},
		{script: `toFloatSlice([1])`, runOutput: []float64{1.0}},
		{script: `toFloatSlice([1.1])`, runOutput: []float64{1.1}},
		{script: `toFloatSlice([true])`, runOutput: []float64{0.0}},
		{script: `toFloatSlice([[]])`, runOutput: []float64{0.0}},
		{script: `toFloatSlice([{}])`, runOutput: []float64{0.0}},
		{script: `toByteSlice(nil)`, runOutput: []byte{}},
		{script: `toByteSlice([])`, runError: fmt.Errorf("function wants argument type string but received type []interface {}")},
		{script: `toByteSlice(1)`, runOutput: []byte{0x01}}, // FIXME?
		{script: `toByteSlice(1.1)`, runError: fmt.Errorf("function wants argument type string but received type float64")},
		{script: `toByteSlice(true)`, runError: fmt.Errorf("function wants argument type string but received type bool")},
		{script: `toByteSlice("foo")`, runOutput: []byte{'f', 'o', 'o'}},
		{script: `toByteSlice("世界")`, runOutput: []byte{0xe4, 0xb8, 0x96, 0xe7, 0x95, 0x8c}},
		{script: `toRuneSlice(nil)`, runOutput: []rune{}},
		{script: `toRuneSlice([])`, runError: fmt.Errorf("function wants argument type string but received type []interface {}")},
		{script: `toRuneSlice(1)`, runOutput: []rune{0x01}}, // FIXME?
		{script: `toRuneSlice(1.1)`, runError: fmt.Errorf("function wants argument type string but received type float64")},
		{script: `toRuneSlice(true)`, runError: fmt.Errorf("function wants argument type string but received type bool")},
		{script: `toRuneSlice("foo")`, runOutput: []rune{'f', 'o', 'o'}},
		{script: `toRuneSlice("世界")`, runOutput: []rune{'世', '界'}},
		{script: `toDuration(nil)`, runOutput: time.Duration(0)},
		{script: `toDuration(0)`, runOutput: time.Duration(0)},
		{script: `toDuration(true)`, runError: fmt.Errorf("function wants argument type int64 but received type bool")},
		{script: `toDuration([])`, runError: fmt.Errorf("function wants argument type int64 but received type []interface {}")},
		{script: `toDuration({})`, runError: fmt.Errorf("function wants argument type int64 but received type map[string]interface {}")},
		{script: `toDuration("")`, runError: fmt.Errorf("function wants argument type int64 but received type string")},
		{script: `toDuration("1s")`, runError: fmt.Errorf("function wants argument type int64 but received type string")}, // TODO
		{script: `toDuration(a)`, input: map[string]interface{}{"a": int64(time.Duration(123 * time.Minute))}, runOutput: time.Duration(123 * time.Minute)},
		{script: `toDuration(a)`, input: map[string]interface{}{"a": float64(time.Duration(123 * time.Minute))}, runOutput: time.Duration(123 * time.Minute)},
		{script: `toDuration(a)`, input: map[string]interface{}{"a": time.Duration(123 * time.Minute)}, runOutput: time.Duration(123 * time.Minute)},
	}
	runTests(t, tests)
}
