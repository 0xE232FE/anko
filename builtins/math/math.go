// Package math implements math interface for anko script.
package math

import (
	"github.com/mattn/anko/vm"
	"math"
	"reflect"
)

func Import(env *vm.Env) {
	m := env.NewModule("math")
	m.Define("Abs", reflect.ValueOf(math.Abs))
	m.Define("Acos", reflect.ValueOf(math.Acos))
	m.Define("Acosh", reflect.ValueOf(math.Acosh))
	m.Define("Asin", reflect.ValueOf(math.Asin))
	m.Define("Asinh", reflect.ValueOf(math.Asinh))
	m.Define("Atan", reflect.ValueOf(math.Atan))
	m.Define("Atan2", reflect.ValueOf(math.Atan2))
	m.Define("Atanh", reflect.ValueOf(math.Atanh))
	m.Define("Cbrt", reflect.ValueOf(math.Cbrt))
	m.Define("Ceil", reflect.ValueOf(math.Ceil))
	m.Define("Copysign", reflect.ValueOf(math.Copysign))
	m.Define("Cos", reflect.ValueOf(math.Cos))
	m.Define("Cosh", reflect.ValueOf(math.Cosh))
	m.Define("Dim", reflect.ValueOf(math.Dim))
	m.Define("Erf", reflect.ValueOf(math.Erf))
	m.Define("Erfc", reflect.ValueOf(math.Erfc))
	m.Define("Exp", reflect.ValueOf(math.Exp))
	m.Define("Exp2", reflect.ValueOf(math.Exp2))
	m.Define("Expm1", reflect.ValueOf(math.Expm1))
	m.Define("Float32bits", reflect.ValueOf(math.Float32bits))
	m.Define("Float32frombits", reflect.ValueOf(math.Float32frombits))
	m.Define("Float64bits", reflect.ValueOf(math.Float64bits))
	m.Define("Float64frombits", reflect.ValueOf(math.Float64frombits))
	m.Define("Floor", reflect.ValueOf(math.Floor))
	m.Define("Frexp", reflect.ValueOf(math.Frexp))
	m.Define("Gamma", reflect.ValueOf(math.Gamma))
	m.Define("Hypot", reflect.ValueOf(math.Hypot))
	m.Define("Ilogb", reflect.ValueOf(math.Ilogb))
	m.Define("Inf", reflect.ValueOf(math.Inf))
	m.Define("IsInf", reflect.ValueOf(math.IsInf))
	m.Define("IsNaN", reflect.ValueOf(math.IsNaN))
	m.Define("J0", reflect.ValueOf(math.J0))
	m.Define("J1", reflect.ValueOf(math.J1))
	m.Define("Jn", reflect.ValueOf(math.Jn))
	m.Define("Ldexp", reflect.ValueOf(math.Ldexp))
	m.Define("Lgamma", reflect.ValueOf(math.Lgamma))
	m.Define("Log", reflect.ValueOf(math.Log))
	m.Define("Log10", reflect.ValueOf(math.Log10))
	m.Define("Log1p", reflect.ValueOf(math.Log1p))
	m.Define("Log2", reflect.ValueOf(math.Log2))
	m.Define("Logb", reflect.ValueOf(math.Logb))
	m.Define("Max", reflect.ValueOf(math.Max))
	m.Define("Min", reflect.ValueOf(math.Min))
	m.Define("Mod", reflect.ValueOf(math.Mod))
	m.Define("Modf", reflect.ValueOf(math.Modf))
	m.Define("NaN", reflect.ValueOf(math.NaN))
	m.Define("Nextafter", reflect.ValueOf(math.Nextafter))
	m.Define("Pow", reflect.ValueOf(math.Pow))
	m.Define("Pow10", reflect.ValueOf(math.Pow10))
	m.Define("Remainder", reflect.ValueOf(math.Remainder))
	m.Define("Signbit", reflect.ValueOf(math.Signbit))
	m.Define("Sin", reflect.ValueOf(math.Sin))
	m.Define("Sincos", reflect.ValueOf(math.Sincos))
	m.Define("Sinh", reflect.ValueOf(math.Sinh))
	m.Define("Sqrt", reflect.ValueOf(math.Sqrt))
	m.Define("Tan", reflect.ValueOf(math.Tan))
	m.Define("Tanh", reflect.ValueOf(math.Tanh))
	m.Define("Trunc", reflect.ValueOf(math.Trunc))
	m.Define("Y0", reflect.ValueOf(math.Y0))
	m.Define("Y1", reflect.ValueOf(math.Y1))
	m.Define("Yn", reflect.ValueOf(math.Yn))
}
